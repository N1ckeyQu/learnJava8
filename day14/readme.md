# day14 学习

## abstract

> 抽象的。它可以修饰类和方法

- abstract修饰类：类不能被实例化

  注意：虽然抽象类不能被实例化，但是抽象类中还是包含构造器的。虽然抽象类自己不能被实例化，但是子类实例化的时候还是会调用父类构造器的

- abstract修饰方法：抽象方法没有方法体

  注意：抽象方法只能存在于抽象类中，因此抽象类中可以包含抽象方法，也可以包含普通方法

子类继承抽象类后，如果没有重写抽象类中全部的抽象方法，那么子类也是一个抽象类，需要用abstract关键字修饰

注意：

1. abstract不能用于修饰属性，因为属性没有继承/重写这种关系
2. abstract不能修饰构造器，因为构造器是用于创建当前类对象的，它的内容必然是具体，当然不能被abstract修饰
3. abstract不能用于修饰private方法，因为私有方法你获取不到，自然无法被重写，abstract也就失去了意义
4. abstract不能用于修饰static方法，这个跟重写有关，如果子父类中同方法名同形参的方法都是static，这里我们并不视为重写，因为静态方法随着类的加载而加载，因此静态方法是无法被重写的
5. final方法和final类也不能被abstract修饰

## interface

实现接口关键字是implements，实现继承的关键字是extends，继承父类和实现接口，分别适用于不同的场景。

### 继承父类

当我们有Person类、Man类和Woman类时，很显然Man是Person，因此Man需要继承Person，这是一个“是不是”的问题

### 实现接口

鼠标、键盘、麦克风都可以通过USB的方式进行连接，那我们是否应该创建一个USB连接的类，然后让鼠标、键盘、麦克风继承该类呢？很显然这是不对的，USB连接的方式是一种属性，或者叫规则，这种规则不应该被抽象成一个类，此时就是接口大显身手的时候了。接口就是用来体现规则/标准的，既然鼠标、键盘、麦克风都支持USB连接，那么我们可以创建一个USB接口，让这三个类分别实现该接口，使得三者都能使用USB连接的方式，这是一个“如果我实现了xx接口，我就能xx”的问题

### 复习

之前我们说Java的类是单继承的，有些情况下难免会遇到一个类同时想拥有多个类的特有结构，接口某种程度上可以帮助我们，因为接口是可以多实现的，并且接口和类属于同一层级的结构，因此接口与接口之间也是可以继承的

## 内部类

### 普通内部类

其实普通内部类实际开发中用的并不多，更多是把一个类单独拎出来写。我觉得如果这个内部类跟当前类有着很强的联系，并且外部很少用到这个内部类，那么这种写法可以接受

### 静态内部类

内部类可以被static所修饰

### 匿名内部类

比如我们写了一个抽象类/接口，但是我们还没有写具体的子类/实现类，并且抽象类/接口是不能被实例化的，但我们又想要调用抽象类/接口中的方法，就可以使用匿名内部类

```java
package com.learn;

public class AbstractTest {
    public static void main(String[] args) {
        Person p = new Person() {
            @Override
            public void sum() {
                System.out.println("lala");
            }
        };

        Fly f = new Fly() {
            @Override
            public void fly() {
                System.out.println("飞翔");
            }
        };

        f.fly();
    }
}

interface Fly {
    void fly();
}

abstract class Person {
    String name;
    int age;

    public abstract void sum();
}
```

这里虽然我们使用了new关键字，但我们并不是真的实例化对象，可以理解为创建了一个子类/实现类，我们在这里重写了抽象类/接口中的方法，但是我们在这里创建的子类/实现类的名称是没有的，这也是“匿名”的由来
