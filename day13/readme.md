# day13 学习

## 代码块

> 代码块用于初始化类、对象，它只能被static修饰，因此被分为静态代码块和非静态代码块

### 静态代码块

静态代码块用于初始化该类中的一些信息，它随着类的加载而执行，并且只执行一次。如果类中有多个静态代码块，按照声明的先后顺序执行

如果类中同时声明了静态代码块和非静态代码块，静态代码块要先于非静态代码块执行

由于类中结构的生命周期限制，静态代码块中不能调用非静态的结构

### 非静态代码块

非静态代码块用于初始化实例化对象中的一些信息，它随着类的实例化而执行，new了多少个对象，就执行多少次

如果类中有多个非静态代码块，按照声明的先后顺序执行

非静态代码块内可以调用静态结构

### 执行顺序

如果子类和父类中都声明了静态代码块和非静态代码块。牢记：**由父及子，静态先行**

代码块的执行优先级要高于构造器

## 属性赋值的位置

- 默认初始化
- 显示初始化
- 构造器初始化
- 对象.属性、对象.方法，给属性赋值
- 代码块中赋值

这五种给属性赋值的位置，优先级各不相同，1 > 2/5 > 3  > 4。其中显示初始化和在代码块中赋值，优先级是相同的，因此就要看类中声明的顺序如何了

## final关键字

> final意味着“最终的”，它可以修饰类、方法、属性

- final修饰类时，该类无法被继承，因为它是一个“最终的”类

- final修饰方法时，该方法无法被重写

- final修饰属性时，该属性被称为常量，常量无法改变，因此常量必须进行初始化

  初始化有好几种手段，哪几种对常量好使？

  1. 显示初始化
  2. 代码块中赋值
  3. 构造器中赋值

- final修饰局部变量时，局部变量不能被修改

- final修饰形参时，该形参在方法体内部无法被修改

## static修饰的属性，相较于实例变量有哪些特别之处

static修饰的属性是属于类本身的，它随着类的加载而加载，让我们修改static属性的时候，不管你使用哪个实例对象访问static属性，所获得的一定是修改后的static属性

实例变量是专属于当前实例对象的，我修改了实例对象A的属性，不会影响实例变量B

static属性保存在方法区的静态域中

## final可以用来修改哪些结构，分别表示什么意思

- 属性

  此时属性可以被初始化，但不能被修改

  可以显示初始化、代码块初始化、构造器初始化

- 局部变量

  此时局部变量无法被修改

- 方法

  该方法无法被重写

- 类

  该类无法被继承

## 代码实现单例模式的饿汉式

```java
package com.learn;

/**
 * 单例模式：饿汉式
 */
public class Hungry {
    private static Hungry instance = new Hungry();

    private Hungry() {

    }

    public static Hungry getInstance() {
        return instance;
    }

}
```

## 代码实现单例模式的懒汉式

```java
package com.learn;

import java.util.Objects;

/**
 * 单例模式——懒汉式
 */
public class Full {
    private static Full instance = null;

    private Full() {

    }

    public static Full getInstance() {
        if (Objects.isNull(instance)) {
            instance = new Full();
        }
        return instance;
    }

}
```

## 类的属性赋值的位置有哪些？先后顺序？

- 默认初始化
- 显示初始化
- 代码块赋值
- 构造器赋值
- 对象.属性/对象.方法

1 > 2/3 > 4 > 5

