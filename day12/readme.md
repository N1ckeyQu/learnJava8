# day12学习

## instanceof关键字的使用

a是A的子类，当我们使用向上转型创建a类的实例时，如果我们想要调用a类中一些特有的结构时，是不被允许的

解决这个问题有这样几种手段：

- a a = new a(); 从一开始就不使用向上转型

- A a = new a();

  a instance = (a) a;

  将A类的实例强转成a类的实例。当然，这种强转是有风险的，这种风险在编译期无法被识别

  if (a instanceof A) {

  

  }

  使用instanceof就可以规避这种风险，它的作用是判断a是不是A的子类，并返回一个布尔值

## equals方法

Object类中的equals方法非常简单，其实就是==，比较的是obj的地址值。而jdk的作者考虑到日常的开发情况，提前帮我们重写了String、File、Date、包装类中的equals方法，重写的逻辑就是基于内容的比较，而不是比较地址值

基于上述情况，假如我们自定义的类也需要涉及到比较，这时候我们就可以在自定义类中重写equals方法，根据我们的自定义逻辑来判断什么情况下相等

## 包装类

对基本数据类型进行封装，将基本数据类型包装成一个类。成为类之后，就具备了面向对象的能力，Java才真正是一门面向对象的语言

## 复习

### 如何实现向下转型

通过强转实现。但是强转是有风险的，需使用instanceof关键字来判断被强转类和强转后的类是否存在子父类关系

### ==和equals的区别

==是个运算符，而equals是Object类中的方法。原始的equals方法内部的逻辑就是==，但是子类可以重写equals方法，进而编写自定义的逻辑来判断是否相等。为了方便日常开发，jdk已经帮我们重写了一部分类的equals方法，比如String、File、Date，以及包装类

日常开发中也会有一些需要重写equals方法的场景，IDE一般都会提供自动生成equals方法代码的功能，很少需要我们手写，除非是一些特定的业务逻辑需要我们加进去

### 写出8种基本数据类型及其对应的包装类

int —— Integer

char —— Character

就这两个搞特殊，其它都是首字母改称大写就行

### 基本数据类型、包装类、String三者之间的转换

- 基本数据类型转包装类：自动装箱
- 包装类转基本数据类型：自动拆箱
- 基本数据类型转String：String.valueOf()
- String转基本数据类型：Integer.valueOf()/Integer.parseInt()，两个都行
- 包装类转String：String.valueOf()，因为可以自动装箱，直接用就行^^
- String转包装类：Integer.valueOf()